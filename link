https://laodong.vn/the-gioi/thoi-diem-chinh-thuc-cong-bo-ket-qua-bau-cu-tong-thong-my-851456.ldo




https://howtodoinjava.com/spring-boot2/rest/enableasync-async-controller/
https://spring.io/guides/gs/async-method/#:~:text=The%20%40EnableAsync%20annotation%20switches%20on,name%20for%20which%20Spring%20searches.

Nhìn thấy bên trái không có đỉnh, thì có thể đã quá tăng, tạm thời đứng ngoài, ngó luôn MACD kẻo có phân kỳ, hội tụ
Nhận biết đưuòng giá đang trong giai đoạn nào

https://medium.com/@joeclever/using-multiple-datasources-with-spring-boot-and-spring-data-6430b00c02e7

https://www.logicbig.com/how-to/code-snippets/jcode-spring-framework-threadpooltaskexecutor.html


Error: Unable to acquire JDBC Connection
Answer:
Sounds to me like an issue with your transaction boundaries, which aren't releasing the connections back to the pool. 
Could you try putting @Transactional on your LogRepositoryImpl class?
```
    @Repository
    @Transactional
    public class LogRepositoryImpl implements LogRepository {
        . . . 
    }
```

Phải sử dụng annotation @Transactional để khi có Exception thì nó sẽ rollback và đóng connection
Còn nếu không sử dụng @Transactional thì khi có exception nó sẽ không callback mà còn GIỮ LUÔN connection ở trong pool và sẽ không còn connection Nhàn Rỗi cho 1 request khác
    tới database, đâm ra sẽ bị timeout connection khác.
Ví dụ: hãy viết 1 Store Procedure và dung Hiraki làm 1 pull, mình sẽ có 1 for loop để request tới Database để gọi store đó để quăng ra exception
       Test 1: theo kiểu lần 1 để @Transactional và xem kết quả
       Test 2: không để @Transactional và xem kết quả là: nếu connection pool là 20 thì nó sẽ loop 20 lần có quăng ra exeption và giữ luôn connection đó và không đóng
               nên từ vòng lặp thứ 21 sẽ bị timeout do đầy connection rồi. Các khắc phục là để annotaion @Transactional để nó rollback và đóng connection khi có Exception.
